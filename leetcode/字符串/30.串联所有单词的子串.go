package main

/*
 * @lc app=leetcode.cn id=30 lang=golang
 *
 * [30] 串联所有单词的子串
 */

// @lc code=start

//时间来不及了，讲讲思路

//解法一：如果说words组成的单词可以时s中的子串，那么words所有单词的长度肯定和子串的长度相等
//那么我们在s中维护一个长度为m的窗口，然后有两个hash，一个是需要单词的hash[string]int
//一个是当前计数的hash，然后依次匹配这个窗口是否满足需要单词的hash

//这样的话时间复杂度是m * n

//解法二的思想比较精妙，将时间复杂度降低到o(n)
//在解法一当中，解决完了一个窗口对words的匹配，然后窗口++，然后又要重新来一遍
//如果说窗口1匹配完后，窗口2和窗口1只隔wordLen长度的不同，那么就可以利用第一个窗口已知的信息
//分为三种情况：
//（1）窗口1和words完全匹配，然后不需要清零hash，只需要hash把之前那个字符减一
//(2)如果窗口一的某个单词出现了不匹配，那么直接把窗口2移动到这个字符的末尾
//(3)如果窗口一没有额外的单词，但是仍旧不匹配，那就是某个单词出现的次数大于了所需要的次数
//那么移动窗口把这个单词的频率降低到所需要

//总而言之就是访问过的字符，不重复访问，只在第一次访问和删除的时候访问，所以整体还是o(n)
func findSubstring(s string, words []string) []int {

}

// @lc code=end
